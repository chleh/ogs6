#!/usr/bin/python

# prevent broken pipe error
from signal import signal, SIGPIPE, SIG_DFL
signal(SIGPIPE,SIG_DFL)

from print23 import print_
import os
import sys
import re

if len(sys.argv) != 3:
    sys.stderr.write("Usage:\n")
    sys.stderr.write("{0} DOCDIR DOCAUXDIR\n".format(sys.argv[0]))
    sys.exit(1)

docdir    = sys.argv[1]
docauxdir = sys.argv[2]

docdir    = os.path.abspath(docdir)
docauxdir = os.path.abspath(docauxdir)
outdir    = os.path.join(docauxdir, "dox", "CTestProjectFiles")

tag_path_expansion_table = {
    "boundary_condition": "prj.process_variables.process_variable.boundary_conditions.boundary_condition",
    "linear_solver":      "prj.linear_solvers.linear_solver",
    "process":            "prj.processes.process",
    "parameter":          "prj.parameters.parameter",
    # "prj": "",
}

tag_path_expansion_table_inv = {}
for k,v in tag_path_expansion_table.items():
    tag_path_expansion_table_inv[v] = k

def dict_of_list_append(dict_, key, value):
    if key in dict_:
        dict_[key].append(value)
    else:
        dict_[key] = [value]

map_path_info = {}

# read parameter cache (generated by normalize-param-cache.py)
with open(os.path.join(docauxdir, "documented-parameters-cache.txt")) as fh:
    for line in fh:
        line = line.strip().split("@@@")
        if line[0] == "OK":
            tagpath = line[3]

            # assume parent tags are also documented
            tagpath_parts = tagpath.split(".")[:-1]
            while tagpath_parts:
                k = (".".join(tagpath_parts), True)
                if k not in map_path_info:
                    map_path_info[k] = []
                tagpath_parts.pop()

            method = line[-1]
            is_tag = method.find("Attribute") == -1
            k = (tagpath, is_tag)
            dict_of_list_append(map_path_info, k, line)
            # print_(tagpath, is_tag)

if False:
    documented_tags_attrs = sorted(map_path_info.keys())
    for ta in documented_tags_attrs:
        print(ta)

class node:
    def __init__(self, name, children=None, attrs=None, is_case=False):
        self.name = name
        self.children = children if children is not None else []
        self.attrs = attrs if attrs is not None else []
        self.is_case = is_case
    def __repr__(self):
        chs = ",".join(c.name for c in self.children)
        ats = ",".join(a.name for a in self.attrs)
        return "<{}  children={} attrs={} is_case={}>".format(self.name, chs, ats, self.is_case)

tree = node("")
map_path_node = { "": tree }

try:
    for (dirpath, _, filenames) in os.walk(docdir):
        reldirpath = dirpath[len(docdir)+1:]

        parentpath = ".".join(reldirpath.split(os.sep)[:-1])
        parentnode = map_path_node[parentpath]
        parentnode.children.append(node(os.path.basename(dirpath)))
        # print "parent dir is", parentnode.name

        # now parentnode and -path are the current directory!
        parentnode = parentnode.children[-1]
        parentpath = reldirpath.replace(os.sep, ".")
        map_path_node[parentpath] = parentnode

        # print "parentpath is", parentpath

        for f in filenames:
            if not f.endswith(".md"): continue
            istag = True
            tagname = f[2:-len(".md")]

            if f.startswith("i_"):
                tagpath = reldirpath
                continue
            elif f.startswith("c_"):
                tagpath = reldirpath
                tagpath = tagpath.replace(os.sep, ".")
                map_path_node[tagpath].is_case = True
                continue
            elif f.startswith("t_"):
                tagpath = os.path.join(reldirpath, tagname)
            elif f.startswith("a_"):
                tagpath = os.path.join(reldirpath, tagname)
                istag = False

            tagpath = tagpath.replace(os.sep, ".")
            if not tagpath:
                continue
                tagpath = "prj"
            assert (tagpath, istag) in map_path_info

            if istag:
                parentnode.children.append(node(tagname))
                map_path_node[tagpath] = parentnode.children[-1]
            else:
                parentnode.attrs.append(node(tagname))
except KeyError:
    raise

# for k in sorted(map_path_node.keys()):
#     print "k", k

if True:
    for k, v in tag_path_expansion_table.items():
        old_node = map_path_node[k]
        new_node = map_path_node[v]
        new_node.children.extend(old_node.children)
        new_node.attrs.extend(old_node.attrs)
        old_node.children = []
        old_node.attrs = []
        i = k.rfind(".")
        if i == -1:
            k_parent_node = map_path_node[""]
        else:
            k_parent_node = map_path_node[k[:i]]
        for i, c in enumerate(k_parent_node.children):
            if c.name == k:
                k_parent_node.children.pop(i)
                break


# print "tree:", tree
#
# for k, v in sorted(map_path_node.items()):
#     print k, v

def get_min_max_type(tagpath, is_tag):
    if tagpath in tag_path_expansion_table:
        tagpath = tag_path_expansion_table[tagpath]
    info = map_path_info[(tagpath, is_tag)]
    min_occ = 1
    max_occ = 1
    data_type = None
    for i in info:
        dt = i[5]
        method = i[6]
        if dt:
            assert data_type is None or data_type == dt
            data_type = dt
        if method.endswith("Optional"):
            min_occ = 0
            max_occ = 1
        elif method.endswith("List"):
            min_occ = 0
            max_occ = "unbounded"

    if data_type is None:
        # print tagpath, "data type is unknown"
        data_type = "xs:string"
    elif data_type == "bool":
        data_type = "xs:boolean"
    elif data_type == "int":
        data_type = "xs:integer"
    elif data_type == "unsigned":
        data_type = "xs:nonNegativeInteger"
    elif data_type == "double":
        data_type = "xs:double"
    elif data_type == "float":
        data_type = "xs:float"
    elif data_type == "std::vector<double>":
        data_type = "prj:Vector_of_Doubles"
    else:
        # all other data types
        data_type = "xs:string"

    return min_occ, max_occ, data_type

def print_tree(node, level=0, path=""):
    if path in tag_path_expansion_table_inv:
        path = tag_path_expansion_table_inv[path]

    if node.children:
        print("{}<{}{}{}>".format("  "*level, node.name,
            " attrs..." if node.attrs else "",
            " is case" if node.is_case else ""))
        for c in node.children:
            print_tree(c, level+1, (path + "." + node.name).lstrip("."))
        print("{}</{}>".format("  "*level, node.name))
    else:
        try:
            p = (path + "." + node.name).lstrip(".")
            dt = ""
            for l in map_path_info[(p, True)]:
                t = l[5]
                assert t == '' or dt == '' or t == dt
                if t: dt = t
            dt = " data type=" + dt
        except:
            dt = " data type is unknown!"
            #raise
        print("{}<{}{}{}{} />".format("  "*level, node.name,
            " attrs..." if node.attrs else "",
            " is case" if node.is_case else "",
            dt))

def get_element(c, p):
    ctype = p + "." + c.name
    if ctype in tag_path_expansion_table_inv:
        ctype = tag_path_expansion_table_inv[ctype]
    mi, ma, dt = get_min_max_type(ctype, True)
    ctype = ctype.replace(".", "__")

    if c.children or c.attrs:
        return '<xs:element name="{}" type="prj:{}" minOccurs="{}" maxOccurs="{}" />\n'.format(c.name, ctype, mi, ma)
    else:
        return '<xs:element name="{}" type="{}" minOccurs="{}" maxOccurs="{}" />\n'.format(c.name, dt, mi, ma)

def write_node(fh, node, p, indent, seq_or_all):
    if node.children:
        fh.write('  '*indent + '<xs:{}>\n'.format(seq_or_all))
        # print "nc", node.children, "\npc", parent_node.children
        for c in sorted(node.children, key=lambda n: n.name):
            if c.is_case: continue
            fh.write('  '*(indent+1) + get_element(c, p))

        fh.write('  '*indent + '</xs:{}>\n'.format(seq_or_all))
        for attr in node.attrs:
            fh.write('  '*indent + '<xs:attribute name="{}" type="xs:string" />\n'.format(attr.name))
    else:
        fh.write('  '*indent + '<xs:simpleContent>\n' + \
                '  '*indent + '  <xs:extension base="xs:string">\n')
        for attr in node.attrs:
            fh.write('  '*indent + '    <xs:attribute name="{}" type="xs:string" />\n'.format(attr.name))
        fh.write('  '*indent + '  </xs:extension>\n' + \
                '  '*indent + '</xs:simpleContent>\n')

def print_tree_xsd(node, fh, level=0, path=""):
    path_orig = path
    if path in tag_path_expansion_table_inv:
        path = tag_path_expansion_table_inv[path]

    if node.children or node.attrs:
        is_polymorphic = False
        # post-order traversal
        for c in node.children:
            print_tree_xsd(c, fh, level+1, (path + "." + node.name).lstrip("."))
            if c.is_case: is_polymorphic = True
            # if re.match("[A-Z]", c.name): is_polymorphic = True

        p = (path + "." + node.name).lstrip(".")
        if p in tag_path_expansion_table_inv:
            p = tag_path_expansion_table_inv[p]
        p2 = p.replace(".", "__")

        if is_polymorphic:
            print p, "is polymorphic"
            fh.write('<xs:complexType name="{}" abstract="true">\n'.format(p2))
            write_node(fh, node, p, 1, "sequence")
            fh.write('</xs:complexType>\n\n')

        elif node.is_case and path != "":
            global map_path_node
            parent_node = map_path_node[path_orig]
            print p, "is case; parent is", path, parent_node.name

            fh.write('<xs:complexType name="{}">\n'.format(p2))
            fh.write('  <xs:complexContent>\n    <xs:extension base="prj:{}">\n'.format(path.replace(".", "__")))
            write_node(fh, node, p, 3, "sequence")
            fh.write('    </xs:extension>\n  </xs:complexContent>\n')
            fh.write('</xs:complexType>\n\n')
        else:
            fh.write('<xs:complexType name="{}">\n'.format(p2))
            write_node(fh, node, p, 1, "sequence" if len(node.children) == 1 else "all")
            fh.write('</xs:complexType>\n\n')
    else:
        pass

    if level == 0:
        fh.write('<xs:element name="OpenGeoSysProject" type="prj:{}" />\n\n'.format(node.name))

with open("ogs-prj-test.xsd", "w") as fh:
    fh.write("""
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
           xmlns:prj="http://www.opengeosys.org/prj.xsd"
           targetNamespace="http://www.opengeosys.org/prj.xsd"
           elementFormDefault="qualified">

<xs:simpleType name="Vector_of_Doubles">
  <xs:list itemType="xs:double" />
</xs:simpleType>

""".lstrip())

    print_tree_xsd(map_path_node["prj"], fh)
    #print_tree(tree)

    fh.write("</xs:schema>\n")


# print(map_path_info[("boundary_condition.type", True)])
